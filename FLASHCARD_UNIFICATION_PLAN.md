# Flashcard Unification Implementation Plan

## 1. Objective
To unify all flashcard-related features into a single, cohesive module. The system must support two distinct types of flashcards within a unified study experience:
1.  **Static Flashcards:** General content (Kanji, Vocabulary, Grammar) shared by all users, managed in the `Express` service.
2.  **Personal Flashcards:** Custom cards created physically by the user or generated by the AI Chatbot, managed in the `Flask` service.

## 2. Current Architecture & Pain Points
*   **Current State:**
    *   Static content lives in `express-db`.
    *   User progress lives in `flask-dynamic-db`.
    *   Current logic "clones" static cards into the user's DB to track progress, leading to data duplication.
    *   Chatbot artifacts (in `Hanachan`) are isolated and not easily "mined" into the permanent review deck.
*   **Pain Points:**
    *   **Data Duplication:** Copying full static data for every user is inefficient.
    *   **Fragmented Experience:** Chatbot generated cards are often lost or exist only in chat history.
    *   **Rigid Review Logic:** Hard to mix "Created by me" cards with "JLPT N3" cards in a single review session.

## 3. Target Architecture

### 3.1 Unified Data Model (Flask Service)

Instead of cloning the *content* of static cards, we will store **References** to static cards and **Content** for personal cards.

**New Schema: `UserFlashcardProgress` (Collection)**
Tracks the SRS state for *any* card.
```json
{
  "_id": "unique_progress_id",
  "user_id": "user_123",
  "card_type": "STATIC" | "PERSONAL",
  "source_id": "original_id_from_source_db",
  "deck_name": "My Custom Deck", // Grouping field (replaces p_tag/s_tag logic)
  "srs_state": {
    "step": 0,
    "interval": 0,
    "ease_factor": 2.5,
    "next_review_at": "ISODate(...)"
  },
  "tags": ["JLPT_N5", "Mining", "Chatbot"]
}
```

**New Schema: `PersonalCard` (Collection)**
Stores content for user/bot created cards.
```json
{
  "_id": "unique_card_id",
  "user_id": "user_123",
  "original_creator": "user" | "hanachan",
  "front": "Content...",
  "back": "Content...",
  "type": "vocabulary" | "sentence" | "kanji",
  "default_deck": "Inbox", // Default deck assignment
  "created_at": "ISODate(...)"
}
```

> **Design Note: Why separate `PersonalCard` from `UserFlashcardProgress`?**
> We separate **Content** (Front/Back) from **Progress** (SRS Level, Next Due Date) to treat all cards uniformly.
> *   **Unified Review Query:** To find "What is due today?", we only query *one* collection (`UserFlashcardProgress`) instead of checking multiple places.
> *   **Data Normalization:** `PersonalCards` behave exactly like `StaticCards`—they provide the *data*, while the Progress object tracks the *learning*.
> *   **Flexibility:** You could theoretically delete your progress (resetting the SRS) without deleting the card content itself.

### 3.2 Service Responsibilities

| Service | Responsibility |
| :--- | :--- |
| **Express (Content)** | Serves read-only Static Cards (Kanji, Words, Grammar). Provides batch APIs to fetch content by ID list. |
| **Flask (Learning)** | **The Unified Module.** <br>1. Manages `UserFlashcardProgress`.<br>2. Manages `PersonalCard` content.<br>3. **Deck Management:** Allows creating, renaming, and deleting "Decks" (which are effectively distinct values in the `deck_name` field).<br>4. **Aggregator:** Hydrates content for reviews. |
| **Hanachan (AI)** | Generates flashcards. Calls Flask API to save them as `PersonalCard` items when the user clicks "Save" or "Mine". |

## 4. Implementation Steps

### Phase 1: Database & Schema Refactoring
1.  **Refactor `flashcards.py`:**
    *   Deprecate the "Clone Collection" logic that copies full text.
    *   Implement logic to create "Progress Reference" objects instead.
2.  **Create `PersonalCard` Module:**
    *   Create CRUD endpoints for personal cards: `POST /f-api/v1/cards/personal`.
    *   Ensure creating a personal card automatically initializes a `UserFlashcardProgress` entry for it.

### Phase 2: The Unified Review API
1.  **Implement `GET /f-api/v1/study/due`:**
    *   Query `UserFlashcardProgress` for items where `next_review_at` < Now.
    *   Separate results into `static_ids` and `personal_ids`.
    *   **Hydration Step:**
        *   Fetch `personal_ids` content from local `PersonalCard` collection.
        *   Fetch `static_ids` content via HTTP call to Express (`POST /e-api/v1/batch-fetch`).
    *   Merge results into a uniform JSON format for the Frontend.

### Phase 3: Chatbot Integration (The Bridge Pattern)
**How the Chatbot creates cards:**
The Chatbot **does not** write directly to the `flaskFlashcardDB`. Instead, we use a "Human-in-the-loop" flow:

1.  **Generation:** Hanachan generates a `MessageArtifact` (Type: `flashcard`) in the chat stream.
2.  **Persistence (Chat Side):** This artifact is saved in `hanachan_db` so it remains in the chat history.
3.  **Bridge (Frontend):** The UI displays the flashcard with a **"Save to Deck"** button.
4.  **Creation (Flask Side):** When clicked, the Frontend sends the artifact content to `POST /f-api/v1/cards/personal`.
5.  **Result:** The Flask service creates a `PersonalCard` and initializes `UserFlashcardProgress`.

> **Note:** If we want the bot to *automatically* save cards without user confirmation, the `Hanachan` service (Python) can simply make a server-side HTTP POST request to the `Flask` service (Port 5100) directly.

### Phase 4: Frontend Unification
1.  **Unified Flashcard Component (Study Mode):**
    *   Update the React Flashcard component to render cleanly regardless of whether the source was Static or Personal.
    *   Ensure "Answer" submission sends only the `progress_id` (or `source_id` + `type`) to the backend to update SRS state.

2.  **Flashcard Manager UI (CRUD Dashboard):**
    *   **Overview Screen:** A data table listing all active flashcards (both Static and Personal).
        *   *Columns:* Front (Preview), Type (Kanji/Vocab), Source (Static/Personal), SRS Stage (e.g., "Learning", "Review"), Next Review Date.
        *   *Filters:* Filter by Source (Static vs Personal), Tag (e.g., "JLPT N3", "Chatbot"), and Status.
    *   **Create Action:** A modal form to create new `PersonalCard` items manually.
        *   *Fields:* Front, Back, Type, Tags, Notes.
    *   **Edit Action:**
        *   *Personal Cards:* All fields editable.
        *   *Static Cards:* Content is Read-Only. Allow editing of **User Notes** or **Tags** (requires schema update to store user-meta on progress object).
    *   **Delete/Suspend Action:**
        *   *Personal Cards:* Hard delete capability.
        *   *Static Cards:* "Suspend" (Delete Progress Record) to stop reviewing it.

## 5. API Interface Specification

### Create Personal Card
```http
POST /f-api/v1/cards/personal
Content-Type: application/json

{
  "user_id": "...",
  "front": "猫",
  "back": "Cat",
  "type": "vocabulary",
  "tags": ["chatbot-generated"]
}
```

### Get Review Session
```http
GET /f-api/v1/study/session?type=all
```
**Response:**
```json
{
  "queue": [
    {
      "type": "STATIC",
      "srs_id": "123",
      "content": { "kanji": "水", "reading": "mizu", "meaning": "water" }
    },
    {
      "type": "PERSONAL",
      "srs_id": "456",
      "content": { "front": "My Custom Card", "back": "Answer" }
    }
  ]
}
```
