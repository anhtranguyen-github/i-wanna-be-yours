<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Hanachan Chat</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      color: #111;
      background: #f4f4f9;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      background: #fff;
      padding: 16px 24px;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    h1 {
      font-size: 20px;
      margin: 0;
    }

    .container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .sidebar {
      width: 300px;
      background: #fff;
      border-right: 1px solid #ddd;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .main-chat {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 24px;
      gap: 16px;
      overflow: hidden;
    }

    .chat-history {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-right: 8px;
    }

    .message {
      max-width: 80%;
      padding: 12px 16px;
      border-radius: 12px;
      line-height: 1.5;
      position: relative;
    }

    .message.user {
      align-self: flex-end;
      background: #007bff;
      color: #fff;
      border-bottom-right-radius: 2px;
    }

    .message.agent {
      align-self: flex-start;
      background: #fff;
      border: 1px solid #ddd;
      border-bottom-left-radius: 2px;
    }

    /* ... existing styles ... */
    /* Markdown Styles */
    .message p {
      margin: 0 0 8px 0;
    }

    .message p:last-child {
      margin-bottom: 0;
    }

    .message pre {
      background: #f4f4f9;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      border: 1px solid #ddd;
    }

    .message code {
      font-family: Consolas, Monaco, 'Andale Mono', monospace;
      font-size: 13px;
      background: rgba(0, 0, 0, 0.05);
      padding: 2px 4px;
      border-radius: 3px;
    }

    .message pre code {
      background: transparent;
      padding: 0;
      border: none;
    }

    .message ul,
    .message ol {
      margin: 8px 0;
      padding-left: 20px;
    }

    .message table {
      border-collapse: collapse;
      width: 100%;
      margin: 8px 0;
    }

    .message th,
    .message td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: left;
    }

    .message th {
      background: #f0f0f0;
    }

    .message a {
      color: #007bff;
    }

    .message.user a {
      color: #fff;
      text-decoration: underline;
    }

    .input-area {
      background: #fff;
      padding: 16px;
      border-radius: 12px;
      border: 1px solid #ddd;
      display: flex;
      gap: 12px;
      align-items: flex-end;
      /* Align to bottom for multiline text */
      flex-wrap: wrap;
    }

    .file-input-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }

    .file-input-wrapper input[type=file] {
      font-size: 100px;
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      cursor: pointer;
    }

    .btn-icon {
      padding: 10px;
      background: #eee;
      color: #333;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      box-sizing: border-box;
    }

    .btn-icon:hover {
      background: #ddd;
    }

    .image-preview-container {
      width: 100%;
      display: none;
      /* Hidden by default */
      margin-bottom: 8px;
      position: relative;
    }

    .image-preview {
      max-height: 150px;
      border-radius: 8px;
      border: 1px solid #ddd;
    }

    .remove-image {
      position: absolute;
      top: 4px;
      left: 4px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
  </style>
</head>

<body>
  <header>
    <h1>Hanachan Chat</h1>
    <div id="status" class="status">Ready</div>
  </header>
  <div class="container">
    <div class="sidebar">
      <div>
        <label>User ID</label>
        <input id="userId" type="text" value="user_001">
      </div>
      <div>
        <label>Conversation ID</label>
        <div style="display: flex; gap: 8px;">
          <input id="conversationId" type="text" placeholder="UUID">
          <button id="newConvBtn" class="secondary" style="padding: 8px;">+</button>
        </div>
      </div>
      <div>
        <button id="loadHistoryBtn" class="secondary" style="width: 100%;">Load History</button>
      </div>
      <div style="margin-top: auto;">
        <label><input id="thinking" type="checkbox"> Show Thinking</label>
      </div>
    </div>
    <div class="main-chat">
      <div id="chatHistory" class="chat-history">
        <!-- Messages will appear here -->
      </div>

      <!-- Thinking Box (Global for current response) -->
      <div id="thinking-box" class="thinking-box">
        <div class="thinking-header">Thinking Process</div>
        <div id="thinking-content" class="thinking-content"></div>
      </div>

      <div class="input-area">
        <div id="imagePreviewContainer" class="image-preview-container">
          <img id="imagePreview" class="image-preview" src="" alt="Preview">
          <button id="removeImage" class="remove-image">Ã—</button>
        </div>

        <div class="file-input-wrapper">
          <button class="btn-icon">ðŸ“Ž</button>
          <input type="file" id="fileInput" accept="image/*">
        </div>

        <textarea id="query" placeholder="Type a message..."></textarea>
        <button id="send">Send</button>
        <button id="stop" class="secondary">Stop</button>
      </div>
    </div>
  </div>

  <script>
    const queryEl = document.getElementById('query');
    const userIdEl = document.getElementById('userId');
    const conversationIdEl = document.getElementById('conversationId');
    const thinkingEl = document.getElementById('thinking');
    const chatHistoryEl = document.getElementById('chatHistory');
    const thinkingBox = document.getElementById('thinking-box');
    const thinkingContent = document.getElementById('thinking-content');
    const statusEl = document.getElementById('status');
    const sendBtn = document.getElementById('send');
    const stopBtn = document.getElementById('stop');
    const newConvBtn = document.getElementById('newConvBtn');
    const loadHistoryBtn = document.getElementById('loadHistoryBtn');

    // Image Upload Elements
    const fileInput = document.getElementById('fileInput');
    const imagePreviewContainer = document.getElementById('imagePreviewContainer');
    const imagePreview = document.getElementById('imagePreview');
    const removeImageBtn = document.getElementById('removeImage');

    let controller = null;
    let currentImageData = null; // Base64 string

    // Generate UUID
    function uuidv4() {
      return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, c =>
        (+c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> +c / 4).toString(16)
      );
    }

    // Initialize
    if (!conversationIdEl.value) {
      conversationIdEl.value = uuidv4();
    }

    function setStatus(t) { statusEl.textContent = t }

    function appendMessage(role, text, imageSrc = null) {
      const msgDiv = document.createElement('div');
      msgDiv.className = `message ${role.toLowerCase()}`;

      if (imageSrc) {
        const img = document.createElement('img');
        img.src = imageSrc;
        img.style.maxWidth = '100%';
        img.style.maxHeight = '200px';
        img.style.borderRadius = '8px';
        img.style.marginBottom = '8px';
        img.style.display = 'block';
        msgDiv.appendChild(img);
      }

      // Use marked.parse for both user and agent messages when initially appending.
      // For agent messages during streaming, the content will be updated dynamically.
      msgDiv.innerHTML += marked.parse(text);

      chatHistoryEl.appendChild(msgDiv);
      chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
      return msgDiv;
    }

    async function loadHistory() {
      const cid = conversationIdEl.value.trim();
      if (!cid) return;

      setStatus('Loading history...');
      chatHistoryEl.innerHTML = ''; // Clear current view

      try {
        const res = await fetch(`/chat/history?conversation_id=${cid}`);
        if (!res.ok) throw new Error('Failed to load history');
        const data = await res.json();

        (data.history || []).forEach(msg => {
          appendMessage(msg.speaker === 'USER' ? 'user' : 'agent', msg.text);
        });
        setStatus('History loaded');
      } catch (e) {
        setStatus('Error loading history: ' + e.message);
      }
    }

    newConvBtn.onclick = () => {
      conversationIdEl.value = uuidv4();
      chatHistoryEl.innerHTML = '';
      setStatus('New conversation started');
    };

    loadHistoryBtn.onclick = loadHistory;

    // --- Image Handling ---

    fileInput.onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      try {
        const base64 = await processImage(file);
        currentImageData = base64;
        imagePreview.src = `data:image/png;base64,${base64}`;
        imagePreviewContainer.style.display = 'block';
      } catch (err) {
        alert("Error processing image: " + err.message);
      }
      // Reset input so same file can be selected again if needed
      fileInput.value = '';
    };

    removeImageBtn.onclick = () => {
      currentImageData = null;
      imagePreview.src = '';
      imagePreviewContainer.style.display = 'none';
    };

    function processImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const maxDim = 1024;
            let width = img.width;
            let height = img.height;

            if (width > maxDim || height > maxDim) {
              if (width > height) {
                height *= maxDim / width;
                width = maxDim;
              } else {
                width *= maxDim / height;
                height = maxDim;
              }
            }

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);

            // Get base64 string (remove data:image/png;base64, prefix)
            const dataUrl = canvas.toDataURL('image/png');
            const base64 = dataUrl.split(',')[1];
            resolve(base64);
          };
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    async function runStream(q, t, cid, uid, imgData) {
      controller = new AbortController();
      const url = '/chat/stream' + (t ? '?thinking=true' : '');

      // Create a placeholder for the AI response
      let aiMsgDiv = null;
      let buffer = '';
      let fullResponse = ''; // Keep track of full response for markdown rendering

      // Reset thinking box for new turn
      thinkingContent.textContent = '';
      thinkingBox.style.display = 'none';

      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            query: q,
            thinking: t,
            conversation_id: cid,
            user_id: uid,
            image_data: imgData // Send image data
          }),
          signal: controller.signal
        });

        if (!res.ok) {
          appendMessage('agent', 'Error ' + res.status);
          return;
        }

        const reader = res.body.getReader();
        const decoder = new TextDecoder();

        let inThinking = false;
        let thinkTag = null;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const text = decoder.decode(value, { stream: true });
          buffer += text;

          // Process buffer
          while (true) {
            if (!inThinking) {
              const startThinking = buffer.indexOf('<thinking>');
              const startThink = buffer.indexOf('<think>');

              let startIdx = -1;
              if (startThinking !== -1 && (startThink === -1 || startThinking < startThink)) {
                startIdx = startThinking;
                thinkTag = 'thinking';
              } else if (startThink !== -1) {
                startIdx = startThink;
                thinkTag = 'think';
              }

              if (startIdx !== -1) {
                // Content before thinking tag is part of the message
                const content = buffer.substring(0, startIdx);
                if (content) {
                  if (!aiMsgDiv) aiMsgDiv = appendMessage('agent', '');
                  fullResponse += content;
                  aiMsgDiv.innerHTML = marked.parse(fullResponse); // Render markdown
                  chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
                }

                buffer = buffer.substring(startIdx + (thinkTag === 'thinking' ? 10 : 7));
                inThinking = true;
                thinkingBox.style.display = 'block';
              } else {
                // Check for partial tag at end
                const lastOpen = buffer.lastIndexOf('<');
                if (lastOpen !== -1 && buffer.length - lastOpen < 10) {
                  // Content before partial tag
                  const content = buffer.substring(0, lastOpen);
                  if (content) {
                    if (!aiMsgDiv) aiMsgDiv = appendMessage('agent', '');
                    fullResponse += content;
                    aiMsgDiv.innerHTML = marked.parse(fullResponse); // Render markdown
                    chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
                  }
                  buffer = buffer.substring(lastOpen);
                  break; // Wait for more data
                } else {
                  // All content is message
                  if (buffer) {
                    if (!aiMsgDiv) aiMsgDiv = appendMessage('agent', '');
                    fullResponse += buffer;
                    aiMsgDiv.innerHTML = marked.parse(fullResponse); // Render markdown
                    chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
                  }
                  buffer = '';
                  break;
                }
              }
            } else {
              const endTag = thinkTag === 'thinking' ? '</thinking>' : '</think>';
              const endIdx = buffer.indexOf(endTag);

              if (endIdx !== -1) {
                thinkingContent.textContent += buffer.substring(0, endIdx);
                thinkingContent.scrollTop = thinkingContent.scrollHeight;
                buffer = buffer.substring(endIdx + endTag.length);
                inThinking = false;
                thinkTag = null;
              } else {
                // Check for partial end tag
                const lastOpen = buffer.lastIndexOf('<');
                if (lastOpen !== -1 && buffer.length - lastOpen < 11) {
                  thinkingContent.textContent += buffer.substring(0, lastOpen);
                  thinkingContent.scrollTop = thinkingContent.scrollHeight;
                  buffer = buffer.substring(lastOpen);
                  break;
                } else {
                  thinkingContent.textContent += buffer;
                  thinkingContent.scrollTop = thinkingContent.scrollHeight;
                  buffer = '';
                  break;
                }
              }
            }
          }
        }
      } catch (e) {
        if (e.name !== 'AbortError') {
          appendMessage('agent', 'Error: ' + e.message);
        }
      }
    }

    sendBtn.onclick = async () => {
      const q = queryEl.value.trim();
      const t = thinkingEl.checked;
      const cid = conversationIdEl.value.trim();
      const uid = userIdEl.value.trim();
      const imgData = currentImageData;

      if (!q && !imgData) return; // Allow sending just image if we want, or require text
      if (!cid) { alert('Please enter a Conversation ID'); return; }

      // Display user message
      let displayImg = null;
      if (imgData) {
        displayImg = `data:image/png;base64,${imgData}`;
      }
      appendMessage('user', q, displayImg);

      queryEl.value = '';
      // Clear image after sending
      currentImageData = null;
      imagePreview.src = '';
      imagePreviewContainer.style.display = 'none';

      setStatus('Sending...');

      await runStream(q, t, cid, uid, imgData);
      setStatus('Ready');
    };

    stopBtn.onclick = () => { if (controller) { controller.abort(); setStatus('Stopped'); } };

    // Allow Enter to send
    queryEl.onkeydown = (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendBtn.click();
      }
    };
  </script>
</body>

</html>